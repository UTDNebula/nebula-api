package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.27

import (
	"context"
	"fmt"

	"github.com/LocatingWizard/nebula_api_graphql/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// CourseByID is the resolver for the courseByID field.
func (r *queryResolver) CourseByID(ctx context.Context, id string) (*model.Course, error) {
	coll := r.DB.Collection("courses")

	oid, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	filter := bson.D{{"_id", oid}}
	var result *model.Course
	err = coll.FindOne(ctx, filter).Decode(&result)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return result, nil
}

// Course is the resolver for the course field.
func (r *queryResolver) Course(ctx context.Context, courseNumber *string, subjectPrefix *string, title *string, description *string, school *string, creditHours *string, classLevel *string, activityType *string, grading *string, internalCourseNumber *string, lectureContactHours *string, offeringFrequency *string) ([]*model.Course, error) {
	coll := r.DB.Collection("courses")

	var results []*model.Course
	filter := bson.D{}

	if courseNumber != nil {
		filter = append(filter, bson.E{"course_number", courseNumber})
	}
	if subjectPrefix != nil {
		filter = append(filter, bson.E{"subject_prefix", subjectPrefix})
	}
	if title != nil {
		filter = append(filter, bson.E{"title", title})
	}
	if description != nil {
		filter = append(filter, bson.E{"description", description})
	}
	if school != nil {
		filter = append(filter, bson.E{"school", school})
	}
	if creditHours != nil {
		filter = append(filter, bson.E{"credit_hours", creditHours})
	}
	if classLevel != nil {
		filter = append(filter, bson.E{"class_level", classLevel})
	}
	if activityType != nil {
		filter = append(filter, bson.E{"activity_type", activityType})
	}
	if grading != nil {
		filter = append(filter, bson.E{"grading", grading})
	}
	if internalCourseNumber != nil {
		filter = append(filter, bson.E{"internal_course_number", internalCourseNumber})
	}
	if lectureContactHours != nil {
		filter = append(filter, bson.E{"lecture_contact_hours", lectureContactHours})
	}
	if offeringFrequency != nil {
		filter = append(filter, bson.E{"offering_frequency", offeringFrequency})
	}

	cursor, err := coll.Find(ctx, filter)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	cursor.All(ctx, &results)
	return results, nil
}

// SectionByID is the resolver for the sectionByID field.
func (r *queryResolver) SectionByID(ctx context.Context, id string) (*model.Section, error) {
	coll := r.DB.Collection("sections")

	oid, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	filter := bson.D{{"_id", oid}}
	var result *model.Section
	err = coll.FindOne(ctx, filter).Decode(&result)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return result, nil
}

// Section is the resolver for the section field.
func (r *queryResolver) Section(ctx context.Context, sectionNumber *string, courseReference *string, internalClassNumber *string, instructionMode *string, syllabusURI *string) ([]*model.Section, error) {
	coll := r.DB.Collection("sections")

	var results []*model.Section
	filter := bson.D{}

	if sectionNumber != nil {
		filter = append(filter, bson.E{"section_number", sectionNumber})
	}
	if courseReference != nil {
		filter = append(filter, bson.E{"course_reference", courseReference})
	}
	if internalClassNumber != nil {
		filter = append(filter, bson.E{"internal_class_number", internalClassNumber})
	}
	if instructionMode != nil {
		filter = append(filter, bson.E{"instruction_mode", instructionMode})
	}
	if syllabusURI != nil {
		filter = append(filter, bson.E{"syllabus_uri", syllabusURI})
	}

	cursor, err := coll.Find(ctx, filter)
	if err != nil {
		return nil, err
	}
	cursor.All(ctx, &results)
	return results, nil
}

// ProfessorByID is the resolver for the professorByID field.
func (r *queryResolver) ProfessorByID(ctx context.Context, id string) (*model.Professor, error) {
	coll := r.DB.Collection("professors")

	oid, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	filter := bson.D{{"_id", oid}}
	var result *model.Professor
	err = coll.FindOne(ctx, filter).Decode(&result)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return result, nil
}

// Professor is the resolver for the professor field.
func (r *queryResolver) Professor(ctx context.Context, firstName *string, lastName *string, titles []string, email *string, phoneNumber *string, profileURI *string, imageURI *string) ([]*model.Professor, error) {
	coll := r.DB.Collection("professors")

	var results []*model.Professor
	filter := bson.D{}

	if firstName != nil {
		filter = append(filter, bson.E{"first_name", firstName})
	}
	if lastName != nil {
		filter = append(filter, bson.E{"last_name", lastName})
	}
	if titles != nil {
		filter = append(filter, bson.E{"titles", titles})
	}
	if email != nil {
		filter = append(filter, bson.E{"email", email})
	}
	if phoneNumber != nil {
		filter = append(filter, bson.E{"phone_number", phoneNumber})
	}
	if profileURI != nil {
		filter = append(filter, bson.E{"profile_uri", profileURI})
	}
	if imageURI != nil {
		filter = append(filter, bson.E{"image_uri", imageURI})
	}

	cursor, err := coll.Find(ctx, filter)
	if err != nil {
		return nil, err
	}
	cursor.All(ctx, &results)
	return results, nil
}

// ExamByID is the resolver for the examByID field.
func (r *queryResolver) ExamByID(ctx context.Context, id string) (model.Exam, error) {
	coll := r.DB.Collection("exams")

	oid, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	filter := bson.D{{"_id", oid}}
	var raw bson.Raw
	err = coll.FindOne(ctx, filter).Decode(&raw)
	if err != nil {
		return nil, err
	}

	switch raw.Lookup("type").StringValue() {
	case "AP":
		var result model.APExam
		err = bson.Unmarshal(raw, &result)
		if err != nil {
			return nil, err
		}
		return result, nil
	case "CLEP":
		var result model.CLEPExam
		err = bson.Unmarshal(raw, &result)
		if err != nil {
			return nil, err
		}
		return result, nil
	case "IB":
		var result model.IBExam
		err = bson.Unmarshal(raw, &result)
		if err != nil {
			return nil, err
		}
		return result, nil
	case "ALEKS":
		var result model.ALEKSExam
		err = bson.Unmarshal(raw, &result)
		if err != nil {
			return nil, err
		}
		return result, nil
	case "CSPlacement":
		var result model.CSPlacementExam
		err = bson.Unmarshal(raw, &result)
		if err != nil {
			return nil, err
		}
		return result, nil
	default:
		return nil, fmt.Errorf("unable to unmarshal exam: %s", err)
	}
}

// Exam is the resolver for the exam field.
func (r *queryResolver) Exam(ctx context.Context, typeArg *string, name *string, level *string) ([]model.Exam, error) {
	coll := r.DB.Collection("exams")

	var results []model.Exam
	filter := bson.D{}

	if typeArg != nil {
		filter = append(filter, bson.E{"type", typeArg})
	}
	if name != nil {
		filter = append(filter, bson.E{"name", name})
	}
	if level != nil {
		filter = append(filter, bson.E{"level", level})
	}

	cursor, err := coll.Find(ctx, filter)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	var raws []bson.Raw

	cursor.All(ctx, &raws)

	for _, raw := range raws {
		switch raw.Lookup("type").StringValue() {
		case "AP":
			var result model.APExam
			err = bson.Unmarshal(raw, &result)
			if err != nil {
				return nil, err
			}
			results = append(results, result)
		case "CLEP":
			var result model.CLEPExam
			err = bson.Unmarshal(raw, &result)
			if err != nil {
				return nil, err
			}
			results = append(results, result)
		case "IB":
			var result model.IBExam
			err = bson.Unmarshal(raw, &result)
			if err != nil {
				return nil, err
			}
			results = append(results, result)
		case "ALEKS":
			var result model.ALEKSExam
			err = bson.Unmarshal(raw, &result)
			if err != nil {
				return nil, err
			}
			results = append(results, result)
		case "CSPlacement":
			var result model.CSPlacementExam
			err = bson.Unmarshal(raw, &result)
			if err != nil {
				return nil, err
			}
			results = append(results, result)
		default:
			return nil, fmt.Errorf("unable to unmarshal exam: %s", err)
		}
	}
	return results, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
